<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>VIC by Selective Intellect</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <link rel="stylesheet" href="stylesheets/zenburn.css">
    <script src="javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/selectiveintellect/vic">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/selectiveintellect/vic/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/selectiveintellect/vic/tarball/master">TAR</a></li>
          <li class="title">DOWNLOAD SOURCE</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">
    <section>
        <div id="title">
        <p>VIC&trade; - A compiler for Microchip&#8217;s PIC&reg; Microcontrollers</p>
        <hr>
        <span class="credits left">Project sponsored by <a
        href="http://selectiveintellect.com">Selective Intellect</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        <br/><br/>
        <span class="credits left"><a href="./index.html">Table of Contents</a></span>
        <span class="credits right"><a href="simulator.html">Prev</a>&nbsp;&nbsp;<a href="index.html">Next</a></span>
        </div>
<h1 id="examples">Examples</h1>

<p>This chapter lists a variety of examples demonstrating how to use VIC&trade;.
Most of these examples can be found in the <code>share/examples</code> folder in the source
code and in your installation.</p>

<p>Wherever necessary the code is explained. Most of the code is quite obvious and
very readable.</p>

<h2 id="helloworld">Hello World!</h2>

<p>This example lights up an LED and can be found in the file
<code>share/examples/helloworld.vic</code>. We also demonstrate how to verify everything
with a simulator <code>sim_assert</code> statement and other statements to visually display
the lighting up of the LED in the simulator interface.</p>

<pre><code>PIC P16F690;

# enable gpsim as a simulator
pragma simulator gpsim;

Main {
    digital_output RC0; # mark pin RC0 as output
    write RC0, 0x1; # write the value 1 to RC0
    sim_assert RC0 == 0x1, &quot;Pin RC0 should be 1&quot;;
}

Simulator {
    attach_led RC0;
    stop_after 1s;
    logfile &quot;helloworld.lxt&quot;;
    log RC0;
    scope RC0;
}
</code></pre>

<h2 id="synchronoustimedelays">Synchronous Time Delays</h2>

<p>This is a generic piece of code that can be used to test whether the <a href="functions.html#timemanagementfunctions"><code>delay</code>
functions</a> work as expected and can create the exact delay needed. That&#8217;s where
the simulators <a href="simulator.html#simulatorcontrol"><code>stopwatch</code> function</a> come in
handy. The code is available in the file <code>share/examples/delay.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    delay 1ms;
    sim_assert &quot;*** EARLY STOP ***&quot;;
}

Simulator {
    stopwatch 1ms;
}
</code></pre>

<h2 id="blinkinganled">Blinking an LED</h2>

<p>This example blinks an LED and can be found in the file
<code>share/examples/blinker.vic</code>.</p>

<pre><code>PIC P16F690;

# enable gpsim as a simulator
pragma simulator gpsim;

Main {
     digital_output RC0;
     Loop {
         write RC0, 1;
         delay 1s;
         write RC0, 0;
         delay 1s;
     }
}

Simulator {
    attach_led RC0, 1, 'green';
    stop_after 30s;
    logfile;
    log RC0;
}
</code></pre>

<h2 id="rotatingoverleds">Rotating over LEDs</h2>

<p>This example rotates the lighting up of an LED in a loop with a port connected
to 4 LEDs. It can be found in the file <code>share/examples/rotater.vic</code>.</p>

<pre><code>PIC P16F690;

# enable gpsim as a simulator
pragma simulator gpsim;

Main {
    digital_output PORTC;
    $display = 0x08; # create a 8-bit register by checking size
    sim_assert $display == 0x08, &quot;$display should be 0x08&quot;;
    Loop {
        write PORTC, $display;
        delay 100ms;
        # improve this depiction
        # circular rotate right by 1 bit
        ror $display, 1;
    }
}

Simulator {
    attach_led PORTC, 4; # attach 4 LEDs to PORTC on RC0-RC3;
    stop_after 60s;
    logfile &quot;rotater.lxt&quot;;
    log PORTC;
    scope PORTC;
}
</code></pre>

<h2 id="usinga7-segmentled">Using a 7-segment LED</h2>

<p>This example demonstrates how to use a simulator 7-segment LED, a look up table
and array indexing to periodically change digits in the LED. Note that the LED
look up table is specific to <code>gpsim</code>, and to use a real 7-segment LED these
values may have to be changed as per the chosen 7-segment LED. This is also
found in the source code as the file <code>share/examples/led7seg.vic</code>.</p>

<pre><code>PIC p16f690;

pragma variable export;
# enable gpsim as a simulator
pragma simulator gpsim;

Main {
    $led7 = table [ 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D,
              0x7D, 0x07, 0x7F, 0x67, 0x77, 0x7C, # this is gpsim specific
              0x58, 0x5E, 0x79, 0x71 ];
    $digit = 0;
    digital_output PORTA;
    digital_output PORTC;
    write PORTA, 0;
    Loop {
        write PORTC, $led7[$digit];
        $digit++;
        $digit &amp;= 0x0F; # bounds check
    }
}

Simulator {
    attach_led7seg RA0, PORTC;
    stop_after 5s;
}
</code></pre>

<h2 id="conditionalloops">Conditional Loops</h2>

<p>This example demonstrates how to use <a href="syntax.html#unconditionalloops">loops</a> and <a href="syntax.html#conditionalblocks">conditional blocks</a> in VIC&trade;.
It is available in the source code as the file <code>share/examples/conditional.vic</code>.
The simulator code is left as an exercise for the reader.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    $var1 = TRUE;
    $var2 = FALSE;
    Loop {
        if $var1 != FALSE &amp;&amp; $var2 != FALSE {
            write PORTC, 1;
            $var1 = !$var2;
        } else if $var1 || $var2 {
            write PORTC, 2;
            $var2 = $var1;
        } else if !$var1 {
            write PORTC, 4;
            $var2 = !$var1;
        } else if $var2 {
            write PORTC, 4;
            $var2 = !$var1;
        } else {
            write PORTC, 8;
            $var1 = !$var2;
        };
        $var3 = 0xFF;
        while $var3 != 0 {
            $var3 &gt;&gt;= 1;
        }
    }
}
</code></pre>

<h2 id="breakingoutofnestedloops">Breaking Out of Nested Loops</h2>

<p>This example demonstrates how to use nested loops and the <a href="syntax.html#conditionalblocks"><code>break</code> and <code>continue</code>
statements</a> to change the execution logic. The simulator code is left as an
exercise to the reader. The code is available in the file
<code>share/examples/loopbreak.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    Loop {
        $dummy = 0xFF;
        while $dummy != 0 {
            $dummy &gt;&gt;= 1;
            write PORTC, 1;
            if $dummy &lt;= 0x0F {
                break;
            }
        }
        while $dummy &gt; 0 {
            $dummy &gt;&gt;= 1;
            write PORTC, 3;
            continue;
        }
        if $dummy == TRUE {
            write PORTC, 2;
            break;
        } else {
            write PORTC, 4;
            continue;
        }
    }
    # we have broken from the loop
    while TRUE {
        write PORTC, 0xFF;
    }
}
</code></pre>

<h2 id="mathematicaloperations">Mathematical Operations</h2>

<p>This code demonstrates the various mathematical operations supported by
VIC&trade; along with verifying them using the simulator&#8217;s <a href="simulator.html#simulatorcontrol"><code>sim_assert</code>
function</a>. All the mathematics is done in 8-bit
mode and the code is available in the file <code>share/examples/math8bit.vic</code>.</p>

<pre><code>PIC P16F690;

pragma variable bits = 8;
pragma variable export;

Main {
    $var1 = 12345;
    sim_assert $var1 == 57, &quot;12345 was placed as 57 due to 8-bit mode&quot;;
    $var2 = 113;
    $var3 = $var2 + $var1;
    sim_assert $var3 == 170, &quot;57 + 113 = 170&quot;;
    $var3 = $var2 - $var1;
    sim_assert $var3 == 56, &quot;113 - 57 = 56&quot;;
    $var3 = $var2 * $var1;
    sim_assert $var3 == 41, &quot;113 * 57 = 41&quot;;
    $var2 = $var2 * 5;
    sim_assert $var2 == 53, &quot;113 * 5 = 565 =&gt; 53 in 8-bit mode&quot;;
    $var3 = $var2 / $var1;
    sim_assert $var3 == 0, &quot;53 / 57 = 0 in integer mathematics&quot;;
    $var3 = $var2 % $var1;
    sim_assert $var3 == 53, &quot;53 % 57 = 53&quot;;
    --$var3;
    sim_assert $var3 == 52, &quot;--53 = 52&quot;;
    ++$var3;
    sim_assert $var3 == 53, &quot;++52 = 53&quot;;
    $var4 = 64;
    $var4 -= $var1;
    sim_assert $var4 == 7, &quot;64 - 57 = 7&quot;;
    $var3 *= 3;
    sim_assert $var3 == 159, &quot;53 * 3 = 159&quot;;
    $var2 /= 5;
    sim_assert $var2 == 10, &quot;53 / 5 = 10&quot;;
    $var4 %= $var2;
    sim_assert $var4 == 7, &quot;7 % 10 = 7&quot;;
    $var4 = 64;
    $var4 ^= 0xFF;
    sim_assert $var4 == 0xBF, &quot;64 ^ 0xFF = 0xBF&quot;;
    $var4 |= 0x80;
    sim_assert $var4 == 0xBF, &quot;0xBF | 0x80 = 0xBF&quot;;
    $var4 &amp;= 0xAA;
    sim_assert $var4 == 0xAA, &quot;0xBF &amp; 0xAA = 0xAA&quot;;
    $var4 = $var4 &lt;&lt; 1;
    sim_assert $var4 == 84, &quot;0xAA &lt;&lt; 1 = 340 which is 84 in 8-bit mode&quot;;
    $var4 = $var4 &gt;&gt; 1;
    sim_assert $var4 == 42, &quot;84 &gt;&gt; 1 = 42&quot;;
    $var4 &lt;&lt;= 1;
    sim_assert $var4 == 84, &quot;42 &lt;&lt; 1 = 84&quot;;
    $var4 &gt;&gt;= 1;
    sim_assert $var4 == 42, &quot;84 &gt;&gt; 1 = 42&quot;;
    $var5 = $var1 - $var2 + $var3 * ($var4 + 8) / $var1;
    sim_assert $var5 == 47, &quot;57 - 10 + ((159 * (42 + 8)) &amp; 0xFF) / 57&quot;;
    $var7 = 13;
    $var5 = ($var1 + (($var3 * ($var4 + $var7) + 5) + $var2));
    sim_assert $var5 == 113,
        &quot;57 + (((159 * (42 + 13)) &amp; 0xFF + 5) + 10) = 113&quot;;
    $var6 = 19;
    $var8 = ($var1 + $var2) - ($var3 * $var4) / ($var5 % $var6);
    sim_assert $var8 == 66, &quot;(57 + 10) - ((159 * 42) &amp; 0xFF) / (113 % 19)&quot;;
    # sqrt is a modifier
    $var3 = sqrt $var4;
    sim_assert $var3 == 6,
        &quot;sqrt(42) = 6.4807 which is 6 in integer mathematics&quot;;
    sim_assert &quot;*** Completed the simulation ***&quot;;
}
</code></pre>

<h2 id="debouncingaswitch">Debouncing a Switch</h2>

<p>This example shows how to debounce a pin input <code>RA3</code> connected to a switch and
simulate the pressing of the switch using the <a href="simulator.html#wavesimulations"><code>stimulate</code>
statement</a>. The example can be found in
<code>share/examples/debouncer.vic</code>.</p>

<pre><code>PIC P16F690;

pragma debounce count = 5;
pragma debounce delay = 1ms;

Main {
    digital_output PORTC;
    digital_input RA3;
    $display = 0;
    Loop {
        debounce RA3,
        Action {
            ++$display;
            write PORTC, $display;
        };
    }
}

Simulator {
    attach_led PORTC, 4, 'red';
    logfile &quot;debouncer.lxt&quot;;
    log RA3;
    scope RA3;
    # stimulus should reflect the debounce delay to be viable
    stimulate RA3, every 5s, wave [
        300, 1, 1300, 0,
        1400, 1, 2400, 0,
        2500, 1, 3500, 0,
        3600, 1, 4600, 0,
        4700, 1, 5700, 0,
        5800, 1, 6800, 0,
        6900, 1, 8000, 0
    ];
    stop_after 30s;
    autorun;
}
</code></pre>

<h2 id="analog-to-digitalconverteradctest">Analog-to-Digital Converter (ADC) Test</h2>

<p>This example demonstrates how to use the ADC of the MCU to read analog
information into a digital variable. We also use that variable to adjust the
delays to modify the speed of the blinking of an LED connected to the pin <code>RC0</code>.
In our case, we tested this on physical hardware where the pin <code>AN0</code> was
connected to a potentiometer switch (variable rotation) and the pin <code>RC0</code> was
connected to an LED. The code can be found in <code>share/examples/adctest.vic</code>.</p>

<pre><code>PIC P16F690;

pragma adc right_justify = 0;
Main {
    digital_output RC0;
    analog_input AN0;
    adc_enable 500kHz, AN0;
    Loop {
        adc_read $display;
        delay_ms $display;
        write RC0, 1;
        delay_ms $display;
        write RC0, 0;
        delay 100us;
    }
}
</code></pre>

<h2 id="variablerotationofleds">Variable Rotation of LEDs</h2>

<p>In this example we use the ADC to change the speed of rotation of 4 LEDs
connected to the <code>PORTC</code> (pins <code>RC0-RC3</code>) of the MCU. The value is read from the
ADC on the <code>AN0</code> analog pin connected to a variable potentiometer which changes
the speed of the lights blinking between the 4 LEDs following the right rotation
pattern of bits. It is an enhanced version of the <a href="#rotatingoverleds">rotating over
LEDs</a> example. This example can be found in <code>share/examples/varrotate.vic</code>.</p>

<pre><code>PIC P16F690;

pragma adc right_justify = 0;

Main {
    digital_output PORTC; # all pins
    analog_input RA3;
    adc_enable 500kHz, AN0;
    $display = 0x08; # create a 8-bit register
    Loop {
        write PORTC, $display;
        adc_read $userval;
        $userval += 100;
        delay_ms $userval;
        ror $display, 1;
    }
}
</code></pre>

<h2 id="reversingledsonswitchpress">Reversing LEDs on Switch Press</h2>

<p>This is a combination of the <a href="#debouncingaswitch">debouncing a switch</a> example and the <a href="#variablerotationofleds">variable
rotation</a> example. In this we assume that a push button switch has been connected
to the <code>RA3</code> pin, 4 LEDs have been connected to each pin on <code>PORTC</code> (pins <code>RC0-RC3</code>)
and that the analog channel/pin <code>AN0</code> is connected to a variable potentiometer.</p>

<p>When the user presses a switch the direction of lighting up the 4 LEDs changes
from left to right and back. When the user rotates the potentiometer, the speed
of blinking of the 4 LEDs changes accordingly. This example can be found in
<code>share/examples/reversible.vic</code>.</p>

<pre><code>PIC P16F690;

pragma debounce count = 2;
pragma debounce delay = 1ms;
pragma adc right_justify = 0;

Main {
    digital_output PORTC;
    digital_input RA3;
    analog_input AN0;
    adc_enable 500kHz, AN0;
    $display = 0x08; # create a 8-bit register
    $dirxn = FALSE;
    Loop {
        write PORTC, $display;
        adc_read $userval;
        $userval += 100;
        delay_ms $userval;
        debounce RA3, Action {
            $dirxn = !$dirxn;
        };
        if $dirxn == TRUE {
            rol $display, 1;
        } else {
            ror $display, 1;
        };
    }
}
</code></pre>

<h2 id="timerusage">Timer Usage</h2>

<p>This example demonstrates how to use the <a href="functions.html#timerandinterruptfunctions">synchronous timer
functions</a> to perform the same task
as the <a href="functions.html#timemanagementfunctions"><code>delay</code> functions</a>. This is very
similar to the <a href="#rotatingoverleds">Rotating over LEDs example</a>, except that
instead of rotating the blinking of the LEDs, it displays the binary values
ranging from <code>0-15</code> on the LEDs connected to <code>PORTC</code> (pins <code>RC0-RC3</code>). This can be
found in the <code>share/examples/timer.vic</code> file.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    $display = 0;
    timer_enable TMR0, 4kHz;
    Loop {
        timer Action {
            ++$display;
            write PORTC, $display;
        };
    }
}
</code></pre>

<h2 id="interruptserviceroutineusage">Interrupt Service Routine Usage</h2>

<p>This example demonstrates how to use the <a href="functions.html#timerandinterruptfunctions">interrupt service
routines</a> to accomplish the same task
as in the <a href="#reversingledsonswitchpress">Reversing LEDs on Switch Press</a> example.
This is available in the <code>share/examples/interrupt.vic</code> file. As you can see,
the ADC is beign read using the interrupt. This is more efficiently implemented
as checking the ADC is now done on an event-based timer instead of using a synchronous MCU loop.</p>

<pre><code>PIC P16F690;

pragma debounce count = 2;
pragma debounce delay = 1ms;
pragma adc right_justify = 0;

Main {
    digital_output PORTC;
    analog_input AN0;
    digital_input RA3;
    adc_enable 500kHz, AN0;
    $display = 0x08; # create a 8-bit register
    $dirxn = FALSE;
    timer_enable TMR0, 4kHz, ISR { #set the interrupt service routine
        adc_read $userval;
        $userval += 100;
    };
    Loop {
        write PORTC, $display;
        delay_ms $userval;
        debounce RA3, Action {
            $dirxn = !$dirxn;
        };
        if ($dirxn == TRUE) {
            rol $display, 1;
        } else {
            ror $display, 1;
        };
    }
}
</code></pre>

<h2 id="pulsewidthmodulationpwm">Pulse Width Modulation (PWM)</h2>

<h3 id="singlepwm">Single PWM</h3>

<p>The <em>single</em> PWM example can be found in <code>share/examples/pwm2.vic</code>. This example
starts a PWM duty cycle at <code>20%</code> and then updates it to <code>30%</code>.</p>

<pre><code>PIC P16F690;

Main {
    pwm_single 1220Hz, 20%, CCP1;
    delay 5s;
    pwm_update 1220Hz, 30%; # update duty cycle
    delay 5s;
}
</code></pre>

<h3 id="half-bridgeandfull-bridgemodes">Half-bridge and Full-bridge Modes</h3>

<p>This example can be modified to run all the different PWM modes by uncommenting
the appropriate line with the required <code>pwm_*bridge</code> function call. It can be found in
<code>share/examples/pwm.vic</code>. Here we see the <em>half bridge</em> mode being used and
uncommenting the other lines will turn on the forward or reverse <em>full bridge</em>
modes.</p>

<pre><code>PIC P16F690;

Main {
    digital_output RC0;
    pwm_halfbridge 1220Hz, 20%, 4us;
    #pwm_fullbridge 'forward', 1220Hz, 20%;
    #pwm_fullbridge 'reverse', 1220Hz, 20%;
    Loop {
        write RC0, CCP1;
    }
}

Simulator {
    attach_led CCP1;
    attach_led RC0;
    stop_after 20s;
    logfile &quot;pwm.lxt&quot;;
    log CCP1;
    scope CCP1, RC0;
    autorun;
}
</code></pre>

<p>This brings us to the end of the list of examples.</p>
    <hr>
    <div id="title">
    <span class="credits left"><a href="./index.html">Table of Contents</a></span>
    <span class="credits right"><a href="simulator.html">Prev</a>&nbsp;&nbsp;<a href="index.html">Next</a></span>
    <br/><br/>
    <p style="font-size:14px;">Vikas N Kumar (<a href="https://github.com/vikasnkumar"
class="user-mention">@vikasnkumar</a>) is the author of
<strong>VIC&trade;</strong>. All copyrights belong to the author and Selective
Intellect LLC.</p>
    <p style="font-size:12px;">VIC&trade; is licensed under the <a
    href="http://dev.perl.org/licenses/">license terms of Perl</a>.
    <br/>
    The development of VIC&trade; is sponsored by <a
    href="http://selectiveintellect.com">Selective Intellect LLC.</a>
    </p>
    <p style="font-size:11px;">
        This page was last updated on 2014-10-30 15:18:10 -0400.
    </p>
    </div>
    </section>
    </div><!-- end wrapper -->
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </body>
