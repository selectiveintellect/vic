<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>VIC by Selective Intellect</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <link rel="stylesheet" href="stylesheets/zenburn.css">
    <script src="javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/selectiveintellect/vic">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/selectiveintellect/vic/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/selectiveintellect/vic/tarball/master">TAR</a></li>
          <li class="title">DOWNLOAD SOURCE</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">
    <section>
        <div id="title">
        <p>VIC&trade; - A compiler for Microchip&#8217;s PIC&reg; Microcontrollers</p>
        <hr>
        <span class="credits left">Project sponsored by <a
        href="http://selectiveintellect.com">Selective Intellect</a></span>
        <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        <br/><br/>
        <span class="credits left"><a href="./index.html">Table of Contents</a></span>
        <span class="credits right"><a href="functions.html">Prev</a>&nbsp;&nbsp;<a href="simulator.html">Next</a></span>
        </div>
<h1>Examples</h1>

<p>This chapter lists a variety of examples demonstrating how to use VIC&trade;.
Most of these examples can be found in the <code>share/examples</code> folder in the source
code and in your installation.</p>

<p>Wherever necessary the code is explained. Most of the code is quite obvious and
very readable.</p>

<h2>Hello World!</h2>

<p>This example lights up an LED and can be found in the file
<code>share/examples/helloworld.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    digital_output RC0; # mark pin RC0 as output
    write RC0, 0x1; # write the value 1 to RC0
}
</code></pre>

<h2>Synchronous Time Delays</h2>

<p>This is a generic piece of code that can be used to test whether the <a href="functions.html#timemanagementfunctions"><code>delay</code>
functions</a> work as expected and can create the exact delay needed. That's where
the simulators <a href="simulator.html#simulatorcontrol"><code>stopwatch</code> function</a> come in
handy. The code is available in the file <code>share/examples/delay.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    # delay 1 second before turning on LED
    delay 1s;
    digital_output RC0; # mark pin RC0 as output
    write RC0, 0x1; # write the value 1 to RC0
}
</code></pre>

<h2>Blinking an LED</h2>

<p>This example blinks an LED and can be found in the file
<code>share/examples/blinker.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
     digital_output RC0;
     Loop {
         write RC0, 1;
         delay 1s;
         write RC0, 0;
         delay 1s;
     }
}
</code></pre>

<h2>Rotating over LEDs</h2>

<p>This example rotates the lighting up of an LED in a loop with a port connected
to 4 LEDs. It can be found in the file <code>share/examples/rotater.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    $display = 0x08; # create a 8-bit register by checking size
    Loop {
        write PORTC, $display;
        delay 100ms;
        # improve this depiction
        # circular rotate right by 1 bit
        ror $display, 1;
    }
}
</code></pre>

<h2>Using a 7-segment LED</h2>

<p>This example demonstrates how to use a simulator 7-segment LED, a look up table
and array indexing to periodically change digits in the LED. Note that the LED
look up table is specific to <code>gpsim</code>, and to use a real 7-segment LED these
values may have to be changed as per the chosen 7-segment LED. This is also
found in the source code as the file <code>share/examples/led7seg.vic</code>.</p>

<pre><code>PIC p16f690;

pragma variable export;

Main {
    $led7 = table [ 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D,
              0x7D, 0x07, 0x7F, 0x67, 0x77, 0x7C, # this is gpsim specific
              0x58, 0x5E, 0x79, 0x71 ];
    $digit = 0;
    digital_output PORTA;
    digital_output PORTC;
    write PORTA, 0;
    Loop {
        write PORTC, $led7[$digit];
        $digit++;
        $digit &amp;= 0x0F; # bounds check
    }
}
</code></pre>

<h2>Conditional Loops</h2>

<p>This example demonstrates how to use <a href="syntax.html#unconditionalloops">loops</a> and <a href="syntax.html#conditionalblocks">conditional blocks</a> in VIC&trade;.
It is available in the source code as the file <code>share/examples/conditional.vic</code>.
The simulator code is left as an exercise for the reader.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    $var1 = TRUE;
    $var2 = FALSE;
    Loop {
        if ($var1 != FALSE &amp;&amp; $var2 != FALSE) {
            $var1 = !$var2;
            write PORTC, 1;
        } else if $var1 || $var2 {
            $var2 = $var1;
            write PORTC, 2;
        } else if !$var1 {
            $var2 = !$var1;
            write PORTC, 4;
        } else if $var2 {
            $var2 = !$var1;
            write PORTC, 4;
        } else {
            write PORTC, 8;
            $var1 = !$var2;
            break;
        };
        $var3 = 0xFF;
        while $var3 != 0 {
            $var3 &gt;&gt;= 1;
        }
    }
}
</code></pre>

<h2>Breaking Out of Nested Loops</h2>

<p>This example demonstrates how to use nested loops and the <a href="syntax.html#conditionalblocks"><code>break</code> and <code>continue</code>
statements</a> to change the execution logic. The simulator code is left as an
exercise to the reader. The code is available in the file
<code>share/examples/loopbreak.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    Loop {
        $dummy = 0xFF;
        while $dummy != 0 {
            $dummy &gt;&gt;= 1;
            write PORTC, 1;
            if $dummy &lt;= 0x0F {
                break;
            }
        }
        while $dummy &gt; 1 {
            $dummy &gt;&gt;= 1;
            write PORTC, 3;
            continue;
        }
        if $dummy == TRUE {
            write PORTC, 2;
            break;
        } else {
            write PORTC, 4;
            continue;
        }
    }
    # we have broken from the loop
    while TRUE {
        write PORTC, 0xFF;
    }
}
</code></pre>

<h2>Mathematical Operations</h2>

<p>This code demonstrates the various mathematical operations supported by
VIC&trade;. All the mathematics is done in 8-bit
mode and the code is available in the file <code>share/examples/math8bit.vic</code>.</p>

<pre><code>PIC P16F690;

pragma variable bits = 8;
pragma variable export;

Main {
    $var1 = 12345;
    $var2 = 113;
    $var3 = $var2 + $var1;
    $var3 = $var2 - $var1;
    $var3 = $var2 * $var1;
    $var2 = $var2 * 5;
    $var3 = $var2 / $var1;
    $var3 = $var2 % $var1;
    --$var3;
    ++$var3;
    $var4 = 64;
    $var4 -= $var1;
    $var3 *= 3;
    $var2 /= 5;
    $var4 %= $var2;
    $var4 = 64;
    $var4 ^= 0xFF;
    $var4 |= 0x80;
    $var4 &amp;= 0xAA;
    $var4 = $var4 &lt;&lt; 1;
    $var4 = $var4 &gt;&gt; 1;
    $var4 &lt;&lt;= 1;
    $var4 &gt;&gt;= 1;
    $var5 = $var1 - $var2 + $var3 * ($var4 + 8) / $var1;
    $var7 = 13;
    $var5 = ($var1 + (($var3 * ($var4 + $var7) + 5) + $var2));
    $var6 = 19;
    $var8 = ($var1 + $var2) - ($var3 * $var4) / ($var5 % $var6);
    # sqrt is a modifier
    $var3 = sqrt $var4;
}
</code></pre>

<h2>Debouncing a Switch</h2>

<p>This example shows how to debounce a pin input <code>RA3</code> connected to a switch and
simulate the pressing of the switch using the <a href="simulator.html#wavesimulations"><code>stimulate</code>
statement</a>. The example can be found in
<code>share/examples/debouncer.vic</code>.</p>

<pre><code>PIC P16F690;

pragma debounce count = 5;
pragma debounce delay = 1ms;

Main {
    digital_output PORTC;
    digital_input RA3;
    $display = 0;
    Loop {
        debounce RA3,
        Action {
            ++$display;
            write PORTC, $display;
        };
    }
}
</code></pre>

<h2>Analog-to-Digital Converter (ADC) Test</h2>

<p>This example demonstrates how to use the ADC of the MCU to read analog
information into a digital variable. We also use that variable to adjust the
delays to modify the speed of the blinking of an LED connected to the pin <code>RC0</code>.
In our case, we tested this on physical hardware where the pin <code>AN0</code> was
connected to a potentiometer switch (variable rotation) and the pin <code>RC0</code> was
connected to an LED. The code can be found in <code>share/examples/adctest.vic</code>.</p>

<p>The difference in use of the <a href="simulator.html#wavesimulations"><code>stimulate</code>
statement</a> is that it accepts floating point
values. When the values are floating point then the stimulus is assumed to be
analog.</p>

<pre><code>PIC P16F690;

pragma adc right_justify = 0;
Main {
    digital_output RC0;
    analog_input AN0;
    adc_enable 500kHz, AN0;
    Loop {
        adc_read $display;
        delay_ms $display;
        write RC0, 1;
        delay_ms $display;
        write RC0, 0;
        delay 100us;
    }
}
</code></pre>

<h2>Variable Rotation of LEDs</h2>

<p>In this example we use the ADC to change the speed of rotation of 4 LEDs
connected to the <code>PORTC</code> (pins <code>RC0-RC7</code>) of the MCU. The value is read from the
ADC on the <code>AN0</code> analog pin connected to a variable potentiometer which changes
the speed of the lights blinking between the 4 LEDs following the right rotation
pattern of bits. It is an enhanced version of the <a href="#rotatingoverleds">rotating over
LEDs</a> example. This example can be found in <code>share/examples/varrotate.vic</code>.</p>

<pre><code>PIC P16F690;

pragma adc right_justify = 0;

Main {
    digital_output PORTC; # all pins
    analog_input RA3;
    adc_enable 500kHz, AN0;
    $display = 0x08; # create a 8-bit register
    Loop {
        write PORTC, $display;
        adc_read $userval;
        $userval += 100;
        delay_ms $userval;
        ror $display, 1;
    }
}
</code></pre>

<h2>Reversing LEDs on Switch Press</h2>

<p>This is a combination of the <a href="#debouncingaswitch">debouncing a switch</a> example and the <a href="#variablerotationofleds">variable
rotation</a> example. In this we assume that a push button switch has been connected
to the <code>RA3</code> pin, 4 LEDs have been connected to each pin on <code>PORTC</code> (pins <code>RC0-RC7</code>)
and that the analog channel/pin <code>AN0</code> is connected to a variable potentiometer.</p>

<p>When the user presses a switch the direction of lighting up the 4 LEDs changes
from left to right and back. When the user rotates the potentiometer, the speed
of blinking of the 4 LEDs changes accordingly. This example can be found in
<code>share/examples/reversible.vic</code>. </p>

<pre><code>PIC P16F690;

pragma debounce count = 2;
pragma debounce delay = 1ms;
pragma adc right_justify = 0;

Main {
    digital_output PORTC;
    digital_input RA3;
    analog_input AN0;
    adc_enable 500kHz, AN0;
    $display = 0x08; # create a 8-bit register
    $dirxn = FALSE;
    Loop {
        write PORTC, $display;
        adc_read $userval;
        $userval += 100;
        delay_ms $userval;
        debounce RA3, Action {
            $dirxn = !$dirxn;
        };
        if $dirxn == TRUE {
            rol $display, 1;
        } else {
            ror $display, 1;
        };
    }
}
</code></pre>

<h2>Timer Usage</h2>

<p>This example demonstrates how to use the <a href="functions.html#timerandinterruptfunctions">synchronous timer
functions</a> to perform the same task
as the <a href="functions.html#timemanagementfunctions"><code>delay</code> functions</a>. This is very
similar to the <a href="#rotatingoverleds">Rotating over LEDs example</a>, except that
instead of rotating the blinking of the LEDs, it displays the binary values
ranging from <code>0-15</code> on the LEDs connected to <code>PORTC</code> (pins <code>RC0-RC7</code>). This can be
found in the <code>share/examples/timer.vic</code> file.</p>

<p>The timer features, if used, are automatically simulated by the simulator and
the user does not have to create any fake stimuli for it.</p>

<pre><code>PIC P16F690;

Main {
    digital_output PORTC;
    $display = 0;
    timer_enable TMR0, 4kHz;
    Loop {
        timer Action {
            ++$display;
            write PORTC, $display;
        };
    }
}
</code></pre>

<h2>Interrupt Service Routine Usage</h2>

<p>This example demonstrates how to use the <a href="functions.html#timerandinterruptfunctions">interrupt service
routines</a> to accomplish the same task
as in the <a href="#reversingledsonswitchpress">Reversing LEDs on Switch Press</a> example.
This is available in the <code>share/examples/interrupt.vic</code> file. As you can see,
the ADC is beign read using the interrupt. This is more efficiently implemented
as checking the ADC is now done on an event-based timer instead of using a synchronous MCU loop.</p>

<p>The interrupt handling is automatically simulated by the simulator, but the
external stimuli like debouncing the switch and analog stimulus have to still be
added by the user.</p>

<pre><code>PIC P16F690;

pragma debounce count = 2;
pragma debounce delay = 1ms;
pragma adc right_justify = 0;

Main {
    digital_output PORTC;
    analog_input AN0;
    digital_input RA3;
    adc_enable 500kHz, AN0;
    $display = 0x08; # create a 8-bit register
    $dirxn = FALSE;
    timer_enable TMR0, 4kHz, ISR { #set the interrupt service routine
        adc_read $userval;
        $userval += 100;
    };
    Loop {
        write PORTC, $display;
        delay_ms $userval;
        debounce RA3, Action {
            $dirxn = !$dirxn;
        };
        if ($dirxn == TRUE) {
            rol $display, 1;
        } else {
            ror $display, 1;
        };
    }
}
</code></pre>

<h2>Reading From Pins</h2>

<p>The reading from pins examples are in the files <code>share/examples/reader.vic</code>,
<code>share/examples/reader_pin.vic</code> and <code>share/examples/reader_port.vic</code>.</p>

<p>Reading is also supported in the simulator by simulating an input read. Each of
these examples demonstrate the various ways of reading from a pin or a port
using direct read, <code>Action</code> block read or <code>ISR</code> read.</p>

<h3>Direct Read</h3>

<p>This example reads from pin <code>RC0</code> and writes to pin <code>RC1</code> the value it has read.
The wave stimulus can be seen in the simulator's scope as well.</p>

<pre><code>PIC P16F690;

Main {
    digital_input RC0;
    digital_output RC1;
    read RC0, $value;
    read RC0, Action {
        $value = shift;
        write RC1, $value;
    };
}
</code></pre>

<h3>Interrupt-on-Change Read</h3>

<p>This example demonstrates using the interrupt-on-change feature of MCU P16F690's
pin <code>RA0</code>. We simulate a wave after a few microseconds that lasts about 2000
microseconds and then see on the scope if the wave has been replicated on pin
<code>RC0</code> with a delay. This example is in <code>share/examples/reader_pin.vic</code>. A
similar example is in <code>share/examples/reader_port.vic</code>.</p>

<pre><code>PIC P16F690;

Main {
    digital_output RC0;
    digital_input RA0;
    read RA0, ISR {
        $value = shift;
        write RC0, $value;
    };
}
</code></pre>

<h2>Pulse Width Modulation (PWM)</h2>

<h3>Single PWM</h3>

<p>The <em>single</em> PWM example can be found in <code>share/examples/pwm2.vic</code>. This example
starts a PWM duty cycle at <code>20%</code> and then updates it to <code>30%</code>.</p>

<p>The PWM is automatically simulated by the simulator and the user just has to
attach an LED and/or a scope to view the output.</p>

<pre><code>PIC P16F690;

Main {
    pwm_single 1220Hz, 20%, CCP1;
    delay 5s;
    pwm_update 1220Hz, 30%; # update duty cycle
    delay 5s;
}
</code></pre>

<h3>Half-bridge and Full-bridge Modes</h3>

<p>This example can be modified to run all the different PWM modes by uncommenting
the appropriate line with the required <code>pwm_*bridge</code> function call. It can be found in
<code>share/examples/pwm.vic</code>. Here we see the <em>half bridge</em> mode being used and
uncommenting the other lines will turn on the forward or reverse <em>full bridge</em>
modes.</p>

<pre><code>PIC P16F690;

Main {
    pwm_halfbridge 1220Hz, 20%, 4us;
    #pwm_fullbridge 'forward', 1220Hz, 20%;
    #pwm_fullbridge 'reverse', 1220Hz, 20%;
}
</code></pre>

<p>This brings us to the end of the list of examples.</p>
    <hr>
    <div id="title">
    <span class="credits left"><a href="./index.html">Table of Contents</a></span>
    <span class="credits right"><a href="functions.html">Prev</a>&nbsp;&nbsp;<a href="simulator.html">Next</a></span>
    <br/><br/>
    <p style="font-size:14px;">Vikas N Kumar (<a href="https://github.com/vikasnkumar"
class="user-mention">@vikasnkumar</a>) is the author of
<strong>VIC&trade;</strong>. All copyrights belong to the author and Selective
Intellect LLC.</p>
    <p style="font-size:12px;">VIC&trade; is licensed under the <a
    href="http://dev.perl.org/licenses/">license terms of Perl</a>.
    <br/>
    The development of VIC&trade; is sponsored by <a
    href="http://selectiveintellect.com">Selective Intellect LLC.</a>
    </p>
    <p style="font-size:11px;">
        This page was last updated on 2021-05-22 20:50:33 -0400.
    </p>
    </div>
    </section>
    </div><!-- end wrapper -->
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </body>
