%grammar vic
%version 0.0.7
#COPYRIGHT: 2014 Vikas N Kumar <vikas@cpan.org>. All Rights Reserved

# uc-select is necessary.
program: uc-select header* statement* EOS

header: uc-config | comment
uc-select: /PIC <BLANK>+ (<uc-types>) <line-ending>/

# P16F690X is fake just to show how to enumerate.
uc-types: /(?i:P16F690 | P16F690X)/
uc-config: /config/ + (name | variable) config-expression line-ending
config-expression: name /<EQUAL> -/ (number-units | number) -

comment: /- <HASH> <ANY>* <EOL>/ | blank-line
blank-line: /- <EOL>/

##FIXME: this needs to be removed really but Pegex has a bug
_: /<BLANK>*/
__: /<BLANK>+/
line-ending: /- <SEMI> - <EOL>?/

statement: comment | instruction | expression | block

block: named-block | conditional-block
named-block: name anonymous-block
conditional-block: - / while | until / - conditional-subject anonymous-block
anonymous-block: start-block statement* end-block
start-block: /- <LCURLY> - <EOL>?/
end-block: /- <RCURLY> - <EOL>?/

instruction: name values line-ending

name: - identifier -
values: (value % COMMA)*
value: - (string | number-units | number | variable | named-block | validated-variable | modifier-variable) -

expression: (assign-expr | unary-expr | conditional-statement) line-ending
unary-lhs: - unary-operator - variable -
unary-rhs: - variable - unary-operator -
unary-expr: unary-lhs | unary-rhs
complement: - complement-operator - rhs-expr -
nested-expr-value: start-nested-expr rhs-expr end-nested-expr
expr-value: - (number | variable | number-units | complement | modifier-variable | nested-expr-value) -
rhs-expr: (expr-value % rhs-operator)+
assign-expr: - variable - assign-operator - rhs-expr

comparison: expr-value compare-operator expr-value
single-conditional: comparison | complement | boolean
conditional-predicate: - (anonymous-block) - COMMA? - (anonymous-block | conditional-statement)* -
conditional-subject: (single-conditional % logic-operator)+
conditional-statement: - / if / - conditional-subject - COMMA - conditional-predicate

complement-operator: /(<TILDE> | <BANG>)/
unary-operator: /(<PLUS> <PLUS> | <DASH> <DASH>)/
assign-operator: /([<PLUS> <DASH> <PERCENT> <CARET> <STAR> <PIPE> <AMP> <SLASH>]? <EQUAL>)/
compare-operator: /([<BANG> <EQUAL> <LANGLE> <RANGLE>] <EQUAL> | (: <LANGLE> | <RANGLE> ))/
logic-operator: /([<AMP> <PIPE>]{2})/
math-operator: /([<PLUS> <DASH> <STAR> <SLASH> <PERCENT>])/
bit-operator: /([<PIPE> <CARET> <AMP>])/
rhs-operator: math-operator | bit-operator
# parentheses
start-nested-expr: /- <LPAREN> -/
end-nested-expr: /- <RPAREN> -/

string: single-quoted-string | double-quoted-string

# most microcontrollers cannot do floating point math so ignore real numbers
number-units: number - units
# number handles both hex and non-hex values for ease of use
number: /(0[xX]<HEX>+ | <DIGIT>+)/ | boolean
units: /(s | ms | us | kHz | Hz | MHz)/
boolean: /( TRUE | FALSE | true | false | 0 | 1)/

validated-variable: identifier
modifier-variable: identifier -  variable
variable: DOLLAR identifier
identifier: /(<ALPHA>[<WORDS>]*)/

single_quoted_string:
    /(:
        <SINGLE>
        ((:
            [^<BREAK><BACK><SINGLE>] |
            <BACK><SINGLE> |
            <BACK><BACK>
        )*?)
        <SINGLE>
    )/

double_quoted_string:
    /(:
        <DOUBLE>
        ((:
            [^<BREAK><BACK><DOUBLE>] |
            <BACK><DOUBLE> |
            <BACK><BACK> |
            <BACK><escape>
        )*?)
        <DOUBLE>
    )/

escape: / [0nt] /
